import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:meta/meta.dart';

import '../../jaspr.dart';
import 'adapters/client_component_adapter.dart';
import 'adapters/document_adapter.dart';
import 'adapters/global_styles_adapter.dart';
import 'async_build_owner.dart';
import 'markup_render_object.dart';
import 'options.dart';
import 'render_functions.dart';

typedef FileLoader = Future<String?> Function(String);

/// Global component binding for the server.
class ServerAppBinding extends AppBinding with ComponentsBinding {
  ServerAppBinding(this.request, {required FileLoader loadFile}) : _fileLoader = loadFile;

  final RequestLike request;
  final FileLoader _fileLoader;

  @override
  bool get isClient => false;

  @override
  String get currentUrl => request.url;

  /// Unmodifiable view of the cookies sent with the [request].
  late final Map<String, String> cookies = () {
    if (request.headers[HttpHeaders.cookieHeader]?.expand((h) => h.split(';')) case final cookies?) {
      return UnmodifiableMapView({
        for (final cookie in cookies.map((cookie) => Cookie.fromSetCookieValue(cookie.trim())))
          cookie.name: cookie.value,
      });
    } else {
      return const <String, String>{};
    }
  }();

  final Map<String, List<String>> responseHeaders = {
    'Content-Type': ['text/html'],
  };

  int responseStatusCode = 200;

  Uint8List? _responseBodyOverride;

  @override
  void attachRootComponent(Component app) async {
    super.attachRootComponent(ClientComponentRegistry(child: app));
  }

  Future<Uint8List> render({bool standalone = false}) async {
    final rootElement = this.rootElement;
    if (rootElement == null) return _emptyResponse;

    if (rootElement.owner.isFirstBuild) {
      final completer = Completer<void>.sync();
      rootElement.binding.addPostFrameCallback(completer.complete);
      await completer.future;
    }

    final root = rootElement.renderObject as MarkupRenderObject;
    final adapters = [..._adapters.reversed, GlobalStylesAdapter(this), if (!standalone) DocumentAdapter()];

    for (final adapter in adapters.reversed) {
      final r = adapter.prepare();
      if (r is Future) {
        await r;
      }
    }

    for (final adapter in adapters) {
      adapter.apply(root);
    }

    if (_responseBodyOverride case final override?) {
      return override;
    }

    return utf8.encode(root.renderToHtml());
  }

  /// Changes the response generated by these bindings to be [body] (either a [Uint8List] or a [String]) instead of
  /// rendering the mounted component.
  @internal
  void overrideBody(Object? body) {
    _responseBodyOverride = switch (body) {
      final Uint8List? bytes => bytes,
      final String text => utf8.encode(text),
      _ => throw ArgumentError.value(body, 'body', 'Must be null, Uint8List or String'),
    };
  }

  @override
  void scheduleFrame(VoidCallback frameCallback) {
    throw UnsupportedError('Scheduling a frame is not supported on the server, and should never happen.');
  }

  @override
  RenderObject createRootRenderObject() {
    return RootMarkupRenderObject();
  }

  @override
  BuildOwner createRootBuildOwner() {
    return AsyncBuildOwner();
  }

  Future<String?> loadFile(String name) => _fileLoader(name);

  final List<RenderAdapter> _adapters = [];

  void addRenderAdapter(RenderAdapter adapter) {
    if (_adapters.contains(adapter)) return;
    _adapters.add(adapter);
  }

  ServerOptions get options => _options!;
  ServerOptions? _options;

  void initializeOptions(ServerOptions options) {
    _options = options;
  }

  @override
  void reportBuildError(Element element, Object error, StackTrace stackTrace) {
    responseStatusCode = 500;
    stderr.writeln('Error while building ${element.component.runtimeType}:\n$error\n\n$stackTrace');
  }

  static final Uint8List _emptyResponse = Uint8List(0);
}

abstract class RenderAdapter {
  FutureOr<void> prepare() {}
  void apply(MarkupRenderObject root) {}
}
