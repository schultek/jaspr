---
title: Client-Side Jaspr
description: Learn about client-side rendering and hydration in Jaspr.
---

*This page is relevant for **all** modes.*

---

The client environment is where all interactivity, event handling, and access to browser APIs happens. In client mode, your app is entirely executed on the client, while in server and static mode, the client-side rendering is started after the initial server-side rendering.

*When using **static** or **server** mode, make sure to also read the [Server-Side Jaspr](/dev/server) page to understand the difference between server and client environments.*

You can choose to compile the client-side part of your app to either JavaScript (default) or WebAssembly (by using the `--experimental-wasm` flag when running `jaspr serve` or `jaspr build`).

## Client Entrypoint

By default, your application's client entrypoint is `lib/main.client.dart`. This file is automatically used by the Jaspr when serving or building your application.

In your entrypoint, you should call the `runApp()` method, which will start the [Hydration](#hydration) process described below.

You can have multiple entrypoints, e.g. for different flavors, by following the `<filename>.client.dart` naming convention (doesn't have to be in root of `lib`). All files matching this pattern will be compiled to either JavaScript or WebAssembly (depending on the `--experimental-wasm` flag) and form a separate client bundle. You can then specify which bundle to use depending on the rendering mode:

<Tabs groupId="mode_combined">
  <TabItem value="static|server" label="Static & Server Mode">

    If you have a peer `<filename>.server.dart` file next to your `<filename>.client.dart` entrypoint, the client bundle is **automatically included** during the server-side rendering.

    For standalone client entrypoints, you need to manually include a script tag pointing to `<filename>.client.dart.js` in your page (usually in `Document(head: [...])`): 

    ```dart
    script(src: 'somefile.client.dart.js', defer: true),
    ```
    
    The `src` path is defined relative to the `lib/` directory and may point to a file in a sub-directory.
  </TabItem>
  <TabItem value="client" label="Client Mode">

    Your client bundle is included as a `<script>` element in your HTML file. You can change the `src` attribute of this element to any entrypoint file as `somefile.client.dart.js`.
    
    ```html
    <script src="somefile.client.dart.js" defer></script>
    ```

    The `src` path is defined relative to the `lib/` directory and may point to a file in a sub-directory.
  </TabItem>
</Tabs>

## Adding Interactivity

## Hydration


While pre-rendering your components on the server (or at built time with 'static' mode) allows for a fast "first contentful paint" (when useful content is first displayed to the user), the site is **not interactive** (e.g. responding to button clicks) until the client-side rendering is started and event handlers have been attached.

In static and server mode your apps lifecycle always **starts on the server**, which builds your components once and render them to html. Then when the browser has loaded your site along with additional files like `.js` or images, your app is executed **again on the client** to continue rendering on the client. This "picking up rendering on the client" is called **Hydration**.

---

For hydration to happen seamlessly the initial client-side render has to match the previously pre-rendered html from the server exactly. This is achieved by re-executing the same components that have previously pre-rendered the html on the server also on the client as soon as the browser loads the page.

With Jaspr you can handle hydration in two ways:

- **manually** by writing both server and client entrypoints separately, or
- **automatically** by using the `@client` annotation.

<Info>
    It is generally recommended to use automatic hydration.
</Info>

---

### Automatic Hydration (Recommended)

For automatic hydration simply use the `@client` annotation on any component.

A component annotated with `@client` will be automatically hydrated on the client after it has been pre-rendered. In principle, this is like 'resuming' the rendering for a component on the client and picking up where the server-side rendering has left off.

<Info>

`@client` components also have other features that are not easily replicable with manual hydration, such as passing data
from server to client or hydrating components dynamically based on server-side state.
</Info>

Read more about `@client` components and how to best use them [here](/api/utils/at_client).

---

### Manual Hydration

With manual hydration, you build a separate component tree in your client entrypoint that needs to match your server-rendered HTML.

In the simplest form, you can mount the same `App` component you use on the server.

```dart title="lib/main.client.dart"
// Client-specific import
import 'package:jaspr/client.dart';

// Our main component
import 'lib/app.dart';

void main() {
  // Attaches the app component to the <body> tag
  // and hydrates the component / makes it interactive.
  runApp(App(), attachTo: 'body');
}
```

This has the same effect as adding `@client` to `App` but forces it to be rendered directly inside the `<body>` element.

--- 

The above approach mounts your whole app on the client. However, when you are building a more content-heavy or mostly static website (static meaning without much user interaction) you probably don't need to ship your whole app structure to the client, but rather want only certain parts of your app to be interactive.

You can choose which part(s) of your app you want to hydrate by mounting only that part in your client entrypoint. This can be done in Jaspr by using the `SlottedChildView` component.

Assuming you have a page layout like this:

```html
<body>
<header>...</header>
<main>
    <div id="content">...</div>
    <div id="sidebar">...</div>
</main>
<footer>...</footer>
</body>
```

Your client entrypoint could be:

```dart title="lib/main.client.dart"
void main() {
  runApp(SlottedChildView(slots: [
    ChildSlot.fromQuery('header', child: Header()),
    ChildSlot.fromQuery('#sidebar', child: Sidebar()),
    ChildSlot.fromQuery('#content', child: Content()),
  ]));
}
```

This will attach the child components to the specified elements using css selectors.

The advantage of this approach is that you can leave other parts of your app, e.g. a static footer,
out of the bundled javascript and thereby reducing loading and startup time.

**Be aware** that on the server, you must still construct the complete app layout and and render the targeted components manually at the right location. Keeping your server and client component tree in sync like this is generally cumbersome and error-prone, therefore it is recommended to use `@client` components instead of manual hydration.

## Working with the DOM

## Using js_interop


