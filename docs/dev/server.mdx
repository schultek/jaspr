---
title: Server-Side Jaspr
description: Understand server-side rendering and how it works with Jaspr.
---

*This page is only relevant when using **static** or **server** mode.*

---

When using Jaspr in **static** or **server** mode, part of your code will be executed on the server to generate the HTML and CSS for your site. This is what is commonly referred to as "server-side rendering".

The term "server" in this context refers to **the environment in which the code is executed**, not the actual hardware running it. In our case, this means either the Dart VM during development, or a native binary when compiled for production. It **does not** refer to the device that is running the code, which may be your local machine (during development), a CI pipeline (during building in "static" mode) or an actual webserver (at runtime in "server" mode).
  
The counterpart to this is the "client" environment, which is either the JavaScript or WASM runtime in the browser that is displaying your website.   

**Learning about and understanding the differences between these environments, and how components are rendered in either environment is crucial to building a successful app with Jaspr.**

## Server Entrypoint

By default in static and server mode, your application's server entrypoint is `lib/main.server.dart`. This file is only executed on the server, hence all components that are rendered from there (the root `Document` component and all its descendents) are rendered on the server.

In your entrypoint, you should call the `runApp()` method, which will start a HTTP server to render your root component and serve any assets in the `/web` directory.

You can have multiple entrypoints, e.g. for different flavors, by following the `<filename>.server.dart` naming convention (doesn't have to be in root of `lib`). You can then change the default entrypoint via the `--input=lib/somedir/somefile.server.dart` flag when running `jaspr serve` and `jaspr build`.

## Component Scopes

With server-side rendering, you can think of your application as being split into two (overlapping) parts:

- **Server Scope**: Includes all components that are server-side rendered.
- **Client Scope**: Includes all components that are client-side rendered.

A component may also be rendered in both environments and therefore be part of both scopes. It is often useful to think of the server scope as the "root" scope, and the client scope as the "child" scope, because usually the server scope defines the root of the component tree with only some component subtrees being rendered also on the client.

Understanding where a component is rendered is crucial to building a successful app with Jaspr, because it defines how and when a component is built, what features can be used, and what platform libraries are available.

<Warning>
Not understanding where a component is rendered can quickly lead to errors and unexpected behavior. For example, if you try to import `dart:js_interop` from a component that is part of the server scope, you will get a compilation error. Same for importing e.g. `dart:io` from a component that is part of the client scope.
</Warning>

While you can manually determine where a component is rendered by back-tracking your import tree back to either a server or client entrypoint, Jaspr provides a more convenient way to do this via the **Jaspr VSCode Extension**.

<Tabs>
  <TabItem label="Using the VSCode Extension" value="vscode">

    For each of your components, you will get a small hint directly in the editor whether that component is rendered on the server and/or on the client. The editor hints for a fullstack component look like this:

    <Image caption="Component Scopes for Counter component" src="/releases/assets/comp_scopes.png" />

    You can click on either server and client hint to see the root(s) of the respective scope, which for the server scope is always the `main()` method of the server entrypoint, and for the client scope is one or more `@client` components.

    <Image caption="Client Scope for Counter component" src="/releases/assets/comp_scope_open.png" />

    Scope hints can optionally be disabled in the settings.
  </TabItem>
  <TabItem label="Manual Reasoning" value="manual">

    When you are not using VSCode, or prefer to manually reason about where a component is rendered, you can do so by back-tracking your import tree back to either a server entrypoint, a client entrypoint or a `@client` component.

    <Accordion title="Here is an \"algorithm\" that describes this in more detail.">
      1. Your apps server entrypoint is `main.server.dart`. This is only executed on the server, hence all components that are rendered from there (the root `Document` component and all its descendents) are rendered on the server.
      2. Go through the component tree top down, starting at the root component and moving downwards through its descendents.
      3. Any component annotated with `@client` is a client component. In addition to being rendered on the server, it is also attached as a root component on the client. This means:
        - It will be rendered both on the server and client.
        - All of its descendents are also rendered both on the server and client.
      2. Additionally, your apps client entrypoint is `main.client.dart`. This is only executed on the client and automatically includes all `@client` components.

      To find out if a particular component is rendered on the server or client, you can turn this around and move up the tree:

      1. Start at the component you want to check.
      2. If it or one of its ancestors is a client component, it is rendered on both the server and client.
      3. Else, it is only rendered on the server.
    </Accordion>

  </TabItem>
</Tabs>

## Server-Only APIs



## Using Platform Libraries




As a result, some or your components will be:

- **only rendered on the server**
- **rendered both on the server and client** 
- **only rendered on the client** (only rarely needed).



## Difference between Server and Client

The main difference between the server and client environments are the platform libraries from the Dart SDK that are available:

- The server environment has access to [Native platform libraries](https://dart.dev/libraries#native-platform-libraries)
- The client environment has access to [Web platform libraries](https://dart.dev/libraries#web-platform-libraries)
  
Therefore, accessing a web-specific library like `dart:js_interop` in a server-rendered component will result in a compilation error. 

If you must access one of these libraries in a component that is rendered in both environments, you have several options:

1. When using [`package:web`](https://pub.dev/packages/web) you should instead use [`package:universal_web`](https://pub.dev/packages/universal_web) which already works across web **and server** environments. No need to use conditional imports or the `@Import` annotation shown below.
2. You can use the [`@Import`](/api/utils/at_import) annotation to import the correct library depending on the environment. This is a shorthand for using [conditional imports](https://dart.dev/guides/libraries/create-packages#conditionally-importing-and-exporting-library-files) and is the recommended way to do this in Jaspr.
3. You can use Dart's [conditional imports](https://dart.dev/guides/libraries/create-packages#conditionally-importing-and-exporting-library-files) to import the correct library depending on the environment. This is a more verbose way of doing the same thing as the `@Import` annotation, but is still valid.

---

Additionally, there are some Jaspr features that are only available in one of the environments. For example:

- Any `event` handlers will only be fired on the client.
- `setState()` may only be called on the client.
- The `Document()` component is only available on the server.
- The `AsyncStatelessComponent` and `AsyncBuilder` components are only available on the server.

## Where is my component rendered?

To write components that works in one or both environments, you need to understand how Jaspr decides where to render your components (or how you control it).

By default, you can reason about your components as follows:

1. Your apps server entrypoint is `main.server.dart`. This is only executed on the server, hence all components that are rendered from there (the root `Document` component and all its descendents) are rendered on the server.
2. Go through the component tree top down, starting at the root component and moving downwards through its descendents.
3. Any component annotated with `@client` is a client component. In addition to being rendered on the server, it is also attached as a root component on the client. This means:
  - It will be rendered both on the server and client.
  - All of its descendents are also rendered both on the server and client.
2. Additionally, your apps client entrypoint is `main.client.dart`. This is only executed on the client and automatically includes all `@client` components.

To find out if a particular component is rendered on the server or client, you can turn this around and move up the tree:

1. Start at the component you want to check.
2. If it or one of its ancestors is a client component, it is rendered on both the server and client.
3. Else, it is only rendered on the server.

<Info>
  Therefore `@client` components act as a sort of boundary. Everything below in the tree is rendered in both environments, while everything above is only rendered on the server.
</Info>

---

To reiterate:

1. Components rendered **only on the server** can safely:
  - use server-side Jaspr features like `Document()`  and `AsyncStatelessComponent`.
  - import and use server-specific libraries like `dart:io`.
  - access the filesystem, connect to a database etc.

2. Components rendered **both on the server and client** can:
  - use client-side Jaspr features like `setState()`.
  - use `kIsWeb` to check if the code is running on the client.
  - **neither** import client- nor server-specific libraries directly. 
    Instead, they must use one of the options mentioned above to import the correct library depending on the environment.

---

For more info regarding this topic, check out the following pages:

- [`@client`](/api/utils/at_client)
- [`@Import`](/api/utils/at_import)
